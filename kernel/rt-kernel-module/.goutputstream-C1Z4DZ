/*
 *		ioctl test module -- Rich West.
 */
#include <linux/module.h>
#include <linux/init.h>
#include <linux/errno.h> 				/* error codes */
#include <linux/proc_fs.h>				/* for create_proc_info_entry() */
#include <asm/uaccess.h>
#include <linux/tty.h>					/* for my_printk() */
#include <linux/sched.h>
#include <linux/kernel.h>
#include <linux/interrupt.h>			/* for request_irq() */
#include <linux/workqueue.h>

/* attribute structures */
struct ioctl_test_t {
	int field1;
	char field2;
};

#define IOCTL_TEST _IOWR(0, 6, struct ioctl_test_t)

#define IOCTL_KEYBOARD _IOWR(0, 7, struct ioctl_test_t)

DECLARE_WAIT_QUEUE_HEAD(my_wq);

static int pseudo_device_ioctl(struct inode *inode, struct file *file,
								unsigned int cmd, unsigned long arg);

static int pseudo_device_read(struct file *, char __user *, size_t, loff_t *);

static int pseudo_device_write(struct file *, const char __user *, size_t, loff_t *);

static struct file_operations pseudo_dev_proc_operations;

static struct proc_dir_entry *proc_entry;

int keyboard_flag = 0;

/* 'printk' version that printst to active tty */
void my_printk(char *string) {
	struct tty_struct *my_tty;
	
	my_tty = current->signal->tty;
	
	if (my_tty != NULL) {
		(*my_tty->driver->ops->write) (my_tty, string, strlen(string));
		(*my_tty->driver->ops->write) (my_tty, "\015\012", 2);
	}
}

static void my_getchar( void *scancode) {
	char c;
	char o;
	
	static char ascii[128] = "\0\e1234567890-=\177\tqwertyuiop[]\n\0"
								 "asdfghjkl;'`\0\\zxcvbnm,./\0*\0 \0\0\0"
								 "\0\0\0\0\0\0\0\0\0\000789-456+1230.\0\0"
								 "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
								 "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
								 "\0\0";
	c = *((char *)scancode) & 0x80;
	o = ascii[(int)c];
	my_printk(&o);
}

static inline unsigned char inb( unsigned short usPort) {
	unsigned char uch;
	
	asm volatile( "inb %1, %0" : "=a" (uch) : "Nd" (usPort));
	return uch;
}

static inline void outb( unsigned char uch, unsigned short usPort) {
	asm volatile("outb %0,%1" :: "a" (uch), "Nd" (usPort));
}

irqreturn_t irq_handler(int irq, void *dev_id) {

	static unsigned char scancode, status;

	status = inb(0x64);
	scancode = inb(0x60);
	
	my_printk("something was clicked\n");
	switch(scancode)
	{
	case 0x01:
		printk("! You pressed Esc ...\n");
		break;
	case 0x3B:
		printk("! You pressed F1 ...\n");
		break;
	case 0x3C:
		my_printk("! You pressed F2 ...\n");
		break;
	default:
		break;
	}
	
	my_getchar(&scancode);
	
	wake_up_interruptible(&my_wq);
	
	return IRQ_HANDLED;
}

static int __init initialization_routine(void) {
	printk("<1> Loading module\n");
	
	pseudo_dev_proc_operations.ioctl = pseudo_device_ioctl;
	pseudo_dev_proc_operations.read = pseudo_device_read;
	pseudo_dev_proc_operations.write = pseudo_device_write;
	
	/* Start create proc entry */
	proc_entry = create_proc_entry("ioctl_test", 0444, NULL);
	
	if (!proc_entry) {
		
		printk ("<1> Error creating /proc entry.\n");
		return 1;
	}
	
	// proc_entry->owner = THIS_MODULE; <-- This is now deprecated
	proc_entry->proc_fops = &pseudo_dev_proc_operations;
	
	return 0;
}

static void __exit cleanup_routine(void) {
	
	if (keyboard_flag == 1) {
		free_irq(1, (void *) (irq_handler));
	}
	printk ("<1> Dumping module\n");
	remove_proc_entry("ioctl_test", NULL);
	return;
}

/***
 *		ioctl() entry point...
 */
 static int pseudo_device_ioctl(struct inode *inode, struct file *file,
									unsigned int cmd, unsigned long arg) {
										
	struct ioctl_test_t ioc;
	
	switch (cmd) {
		case IOCTL_TEST:
			copy_from_user(&ioc, (struct ioctl_test_t *)arg,
							sizeof(struct ioctl_test_t));
			printk ("<1> ioctl: call to IOCTL_TEST (%d, %c)!\n",
					ioc.field1, ioc.field2);
					
			my_printk("Got msg in kernel\n");
			break;
		
		case IOCTL_KEYBOARD:
			keyboard_flag = 1;
			
			free_irq(1, NULL);
			
			if (request_irq(1, irq_handler, IRQF_SHARED,
							"test_keyboard_irq_handler",
							(void *) (irq_handler)) < 0){
				return -EBUSY;
			}
			break;
			
		default:
			return -EINVAL;
			break;
	}
		
	return 0;
}

/***
 * read() entry point...
 */
static int pseudo_device_read(struct file *file, 
							   char __user *buf, 
							   size_t size,
							   loff_t *off)
{
	my_printk("in kernel module read function\n");
	copy_to_user(buf, "hello!!!\0", 9);
	return 0;
}

/***
 * write() entry point...
 */
static int pseudo_device_write(struct file *file,
								const char __user *buf,
								size_t size,
								loff_t *off)
{
	char temp_str[256];
	my_printk("in kernel module write function\n");
	copy_from_user(temp_str, buf, 256);
	my_printk(temp_str);
	return 0;
}

module_init(initialization_routine);
module_exit(cleanup_routine);


MODULE_LICENSE("GPL");
MODULE_AUTHOR("Leo Tomatsu");
MODULE_DESCRIPTION("cs552 Primer Part 1");